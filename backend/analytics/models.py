from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.gis.db import models as gis_models
from crimes.models import CrimeType

User = get_user_model()

class PredictiveModel(models.Model):
    """Model for storing machine learning models used for predictions"""
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    
    # Model type
    MODEL_TYPES = (
        ('hotspot', 'Hotspot Analysis'),
        ('time_series', 'Time Series Forecasting'),
        ('regression', 'Regression Model'),
        ('classification', 'Classification Model'),
        ('clustering', 'Clustering Model'),
        ('ensemble', 'Ensemble Model'),
        ('custom', 'Custom Model')
    )
    model_type = models.CharField(max_length=20, choices=MODEL_TYPES)
    
    # Model target
    target_crime_types = models.ManyToManyField(CrimeType, blank=True, related_name='prediction_models')
    
    # Model files and metadata
    model_file = models.FileField(upload_to='ml_models/', null=True, blank=True)
    model_version = models.CharField(max_length=50, default='1.0.0')
    
    # Model parameters
    parameters = models.JSONField(default=dict, blank=True, 
                                 help_text="Parameters used to train the model")
    
    # Performance metrics
    metrics = models.JSONField(default=dict, blank=True, 
                              help_text="Performance metrics from validation")
    
    # Model status
    STATUS_CHOICES = (
        ('in_development', 'In Development'),
        ('training', 'Training'),
        ('active', 'Active'),
        ('deprecated', 'Deprecated'),
        ('archived', 'Archived')
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='in_development')
    
    # Training data information
    training_date_start = models.DateField(null=True, blank=True)
    training_date_end = models.DateField(null=True, blank=True)
    last_trained = models.DateTimeField(null=True, blank=True)
    
    # Ownership
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_models')
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"{self.name} v{self.model_version} ({self.model_type})"

class Prediction(models.Model):
    """Model for storing crime predictions generated by predictive models"""
    model = models.ForeignKey(PredictiveModel, on_delete=models.CASCADE, related_name='predictions')
    
    # Prediction parameters
    parameters = models.JSONField(help_text="Parameters used for this prediction")
    
    # Prediction area and time period
    area = gis_models.PolygonField(geography=True, spatial_index=True, null=True, blank=True)
    prediction_start_date = models.DateField()
    prediction_end_date = models.DateField()
    
    # Prediction results
    results = models.JSONField(help_text="Prediction results in structured format")
    heatmap_data = models.JSONField(null=True, blank=True, 
                                  help_text="Data for generating prediction heatmaps")
    
    # Confidence metrics
    confidence_level = models.FloatField(null=True, blank=True, 
                                       help_text="Overall confidence in prediction (0-1)")
    
    # Prediction metadata
    generated_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, 
                                    related_name='generated_predictions')
    generated_at = models.DateTimeField(auto_now_add=True)
    
    # Verification (after prediction period has passed)
    is_verified = models.BooleanField(default=False)
    verification_metrics = models.JSONField(null=True, blank=True, 
                                          help_text="Metrics comparing prediction to actual results")
    verified_at = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"Prediction using {self.model.name} for {self.prediction_start_date} to {self.prediction_end_date}"
    
    class Meta:
        ordering = ['-generated_at']

class AnalysisRequest(models.Model):
    """Model for tracking user requests for crime analysis"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='analysis_requests')
    
    # Request details
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    
    # Analysis parameters
    parameters = models.JSONField(help_text="Parameters for the analysis")
    
    # Analysis area and time period
    area = gis_models.PolygonField(geography=True, spatial_index=True, null=True, blank=True)
    start_date = models.DateField()
    end_date = models.DateField()
    
    # Request status
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('canceled', 'Canceled')
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # Results reference
    result_prediction = models.ForeignKey(Prediction, on_delete=models.SET_NULL, null=True, blank=True, 
                                         related_name='result_for')
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"{self.title} - {self.status}"